---
layout: post
title: 如何让Xcode支持模拟器 - JasonMR7
date: 2018-04-03 18:49:00.000000000 +09:00
---



## 背景

在现有的工程上，不支持模拟器编译，原因是自己写的库和一些三方库不支持模拟器编译。



## 正文

### 自己写的库解决方案：

#### 查看支持的架构

怎么看自己写的.framework或者.a文件支持了什么架构呢？

#####.a文件

终端输入lipo -info xxx.a

xxx.a即为.a文件的完整路径

##### .framework

终端输入lipo -info xxx

xxx即为.framework下的xxx(双击打开.framework)

#### 了解架构

执行命令后结果如图：

![了解架构](https://github.com/JasonMR7/JasonMR7.github.io/raw/master/assets/images/2018-04-03-如何让Xcode支持模拟器/支持框架查看1.png "支持框架查看1")

##### 这些个arm是什么意思呢？

__Arm处理器，因为其低功耗和小尺寸而闻名，几乎所有的手机处理器都基于arm，其在嵌入式系统中的应用非常广泛，它的性能在同等功耗产品中也很出色。

Armv6、armv7、armv7s、arm64都是arm处理器的指令集，所有指令集原则上都是**向下兼容**的，如iPhone4S的CPU默认指令集为armv7指令集，但它同时也兼容armv6指令集，只是使用armv6指令集时无法充分发挥其性能，即无法使用armv7指令集中的新特性，同理，iPhone5的处理器标配armv7s指令集，同时也支持armv7指令集，只是无法进行相关的性能优化，从而导致程序的执行效率没那么高。

> 这些指令集在哪些设备中有用到呢？

| arm64                 | armv7s    | armv7                |
| --------------------- | --------- | -------------------- |
| iPad5                 | iPhone 5  | iPhone 4 - iPhone 4S |
| iPad Air - iPad Air 2 | iPhone 5C | iPad - iPad 3        |
| iPad Pro              | iPad 4    | iPad mini            |
| iphone 5s - iPhone X  |           | iPod Touch 3G        |
| iPad mini 2           |           | iPod Touch4          |

![了解架构](https://github.com/JasonMR7/JasonMR7.github.io/raw/master/assets/images/2018-04-03-如何让Xcode支持模拟器/支持框架查看2.png "支持框架查看2")

##### 那i386、x86_64是什么意思呢？

对应的，则为MAC处理器的指令集，i386、x86_64分别是32位及64位的模拟器需要的架构

> 这些指令集在哪些模拟器中有用到呢？

| x86_64                | i386                         |
| --------------------- | ---------------------------- |
| iPad 5                | iPad - iPad 4                |
| iPad Air - iPad Air 2 | iPhone 4 - iPhone5C          |
| iPad Pro              | iPad mini                    |
| iphone5s - iPhoneX    | iPod Touch 3G - iPod Touch 4 |
| iPad mini 2           |                              |

- i386是针对intel通用微处理器32位处理器
- x86_64是针对x86架构的64位处理器



- 模拟器32位处理器测试需要i386架构，

- 模拟器64位处理器测试需要x86_64架构，

- 真机32位处理器需要armv7,或者armv7s架构，

- 真机64位处理器需要arm64架构。

   

### 键盘事件

```objective-c
// Each notification includes a nil object and a userInfo dictionary containing the
// begining and ending keyboard frame in screen coordinates. Use the various UIView and
// UIWindow convertRect facilities to get the frame in the desired coordinate system.
// Animation key/value pairs are only available for the "will" family of notification.
// 通知将带一个userInfo的字典，包括了开始和结束时的frame，动画时间等信息

// 键盘将要展示
UIKIT_EXTERN NSNotificationName const UIKeyboardWillShowNotification __TVOS_PROHIBITED;
// 键盘已经展示
UIKIT_EXTERN NSNotificationName const UIKeyboardDidShowNotification __TVOS_PROHIBITED;
// 键盘将要隐藏
UIKIT_EXTERN NSNotificationName const UIKeyboardWillHideNotification __TVOS_PROHIBITED;
// 键盘已经隐藏
UIKIT_EXTERN NSNotificationName const UIKeyboardDidHideNotification __TVOS_PROHIBITED;
```



userInfo中的信息

```objective-c
// 开始的frame
UIKIT_EXTERN NSString *const UIKeyboardFrameBeginUserInfoKey        NS_AVAILABLE_IOS(3_2) __TVOS_PROHIBITED; // NSValue of CGRect
// 结束的frame
UIKIT_EXTERN NSString *const UIKeyboardFrameEndUserInfoKey          NS_AVAILABLE_IOS(3_2) __TVOS_PROHIBITED; // NSValue of CGRect
// 动画的时间
UIKIT_EXTERN NSString *const UIKeyboardAnimationDurationUserInfoKey NS_AVAILABLE_IOS(3_0) __TVOS_PROHIBITED; // NSNumber of double
// 动画UIViewAnimationCurve类型
UIKIT_EXTERN NSString *const UIKeyboardAnimationCurveUserInfoKey    NS_AVAILABLE_IOS(3_0) __TVOS_PROHIBITED; // NSNumber of NSUInteger (UIViewAnimationCurve)
// 是否为本地用户键盘
UIKIT_EXTERN NSString *const UIKeyboardIsLocalUserInfoKey           NS_AVAILABLE_IOS(9_0) __TVOS_PROHIBITED; // NSNumber of BOOL
```





### 取指定内容坐标

将指定位置滚动到键盘上方当时是获取指定位置点

这里的位置点是Cell的底部任意一点，就取最左边的点吧

点击评论我们可以获取到指定cell的NSIndexPath，通过NSIndexPath我们可以获取到整个Cell的Rect：

```objective-c
CGRect rect = [self.tableView rectForRowAtIndexPath:indexPath];
CGPoint point = CGPointMake(0, rect.origin.y + rect.size.height);
```



好了，位置点已经找到，但是这个位置是相对于UITableView的，而键盘如果是在Window上的，怎么转化呢？



### 转化坐标

为了解决上述问题，我们需要了解几个UIView的方法：

```objective-c
// Converts a point from the receiver’s coordinate system to that of the specified view.
// 将一个点从调用方的坐标系转换为指定视图的坐标系，指定视图如果为nil则默认为Window
- (CGPoint)convertPoint:(CGPoint)point toView:(nullable UIView *)view;
// Converts a point from the coordinate system of a given view to that of the receiver.
// 将一个点从指定视图的坐标系转换为调用方的坐标系，指定视图如果为nil则默认为Window
- (CGPoint)convertPoint:(CGPoint)point fromView:(nullable UIView *)view;

// Converts a rectangle from the receiver’s coordinate system to that of another view.
// 将一个矩形从调用方的坐标系转换为指定视图的坐标系，指定视图如果为nil则默认为Window
- (CGRect)convertRect:(CGRect)rect toView:(nullable UIView *)view;
// Converts a rectangle from the coordinate system of another view to that of the receiver.
// 将一个矩形从指定视图的坐标系转换为调用方的坐标系，指定视图如果为nil则默认为Window
- (CGRect)convertRect:(CGRect)rect fromView:(nullable UIView *)view;
```

什么意思呢？举个例子：![坐标转化](https://github.com/JasonMR7/JasonMR7.github.io/raw/master/assets/images/2018-05-11-UITableView根据评论滚动/坐标转化.png "坐标转化")

图中方块的层级关系是这样的：绿色方块在红色方块上，origin为(0,0)；红色方块在蓝色方块上，origin为(100,100)，那么如果将绿色方块直接放到蓝色方块上，并且视觉上位置不发生变化，那么绿色方块的origin应该是多少呢，我们可以直接用上面的convert方法算出来：

```objective-c
CGPoint newGreenOrigin = [redRect convertPoint:greenRect.frame.origin toView:blueView];
// 或者
CGPoint newGreenOrigin = [blueView convertPoint:greenRect.frame.origin fromView:redRect];
// 两种方法算出来都是(100,100)
```



```objective-c
/**
 接收键盘通知

 @param notification 通知体
 */
- (void)__keyboardWillShow:(NSNotification *)notification {
    // 获取结束时的frame
    CGRect keyboardEndFrame = [notification.userInfo[UIKeyboardFrameEndUserInfoKey] CGRectValue];
    // 还要加上一个toolBar(输入框)的高度，_point为目标位置点，在window上计算偏差值
    CGFloat y = [self.tableView convertPoint:CGPointMake(0, keyboardEndFrame.origin.y - _toolBar.height) fromView:nil].y - _point.y;
    // 根据偏差值算出真正的左上角的目标点
    CGPoint targetPoint = CGPointMake(0, self.tableView.contentOffset.y - y);
    // 值得要注意的是，当y小于0的时候，不要把顶部多余的空白拉下来了
    if (targetPoint.y < 0) {
        targetPoint.y = 0;
    }
    [self.tableView setContentOffset:targetPoint animated:YES];
}
```



### 总结

坐标转化的时候头脑要清晰，转来转去别转晕了就好了



## 参考

[iOS armv7, armv7s, arm64区别与应用32位、64位配置](https://www.jianshu.com/p/567d3b730608)