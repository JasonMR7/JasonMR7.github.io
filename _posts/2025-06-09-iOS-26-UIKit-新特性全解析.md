---
layout: post
title: iOS 26 UIKit 新特性全解析
date: 2025-06-09 18:49:00.000000000 +09:00
---

> 本文根据 **WWDC 2025**（2025 年 6 月）Apple 官方 session 内容整理与翻译，对应 iOS 26 与 UIKit 新特性发布节点。

本次 iOS 26 对 UIKit 进行了全方位升级，涵盖全新设计体系、架构底层优化、容器适配增强、通用能力提升等核心维度，同时引入 Liquid Glass 液态玻璃材质，重构控件视觉与交互，兼顾开发效率与用户体验的双重提升。以下为核心新特性详细解读，搭配图片标注关键效果与流程，更易理解落地。

![uikit1](https://github.com/JasonMR7/JasonMR7.github.io/raw/master/assets/images/2025-06-09-iOS-26-UIKit-新特性全解析/uikit1.webp)

---

## 一、全新设计体系（New design system）

iOS 26 重构了 UIKit 视觉底层，核心围绕 **Liquid Glass 液态玻璃材质**打造，兼具半透明、灵动的视觉质感，同时优化动画与交互逻辑，让操作更流畅。

- UIKit 所有标准组件均基于新材料绘制，视觉统一且适配全设备；
- 导航栏过渡实现流畅可中断动画，无需等待动画结束即可进行下一次操作；
- 内容交互与动画解耦，所有操作无需等待动画收尾，大幅提升交互流畅度。

<video src="https://github.com/JasonMR7/JasonMR7.github.io/raw/master/assets/images/2025-06-09-iOS-26-UIKit-新特性全解析/uikit2.mp4" controls playsinline></video>

<video src="https://github.com/JasonMR7/JasonMR7.github.io/raw/master/assets/images/2025-06-09-iOS-26-UIKit-新特性全解析/uikit3.mp4" controls playsinline></video>

---

## 二、容器与适配增强（Container and adaptivity）

针对多设备（尤其是 iPad）的适配能力大幅升级，强化分屏、布局调整的灵活性，同时引入 macOS 经典交互逻辑。

### 2.1 SplitViewController 可拖动调整大小

iPad 端的分屏控制器支持手动拖动边界调整分屏比例，适配不同使用场景的布局需求，操作逻辑与 macOS 保持一致。

<video src="https://github.com/JasonMR7/JasonMR7.github.io/raw/master/assets/images/2025-06-09-iOS-26-UIKit-新特性全解析/uikit4.mp4" controls playsinline></video>

### 2.2 iPad 引入 macOS 风格菜单栏（The menu bar）

将 macOS 菜单栏能力移植到 iPad，支持自定义配置系统默认命令、插入自定义指令，核心配置代码如下，同时支持命令的增删、替换。

![uikit4](https://github.com/JasonMR7/JasonMR7.github.io/raw/master/assets/images/2025-06-09-iOS-26-UIKit-新特性全解析/uikit4.webp)

```swift
// 主菜单栏系统配置
var config = UIMainMenuSystem.Configuration()
// 包含打印等默认命令
config.printingPreference = .included
// 移除检查器等默认命令
config.inspectorPreference = .removed
// 将查找命令配置为单个「搜索」元素
config.findingConfiguration.style = .search

// 配置菜单栏自定义元素
UIMainMenuSystem.shared.setBuildConfiguration(config) { builder in
    // 在复制命令后插入自定义元素
    builder.insertElements([...], afterCommand: #selector(copy(_:)))
    // 替换删除命令为自定义按键指令
    let deleteKeyCommand = UIKeyCommand(...)
    builder.replace(command: #selector(delete(_:)), withElements: [deleteKeyCommand])
}
```

**【图片 3】** iPad 端 macOS 风格菜单栏效果：展示 iPad 顶部菜单栏样式，标注「系统默认命令」「自定义命令」区域，对应代码中的配置逻辑。

---

## 三、核心架构优化（Architectural improvements）

iOS 26 为 UIKit 注入 **Swift Observation** 响应式能力，并新增专属更新方法，从底层减少冗余操作、提升性能，同时优化动画逻辑，让状态更新与视图渲染更高效。

### 3.1 自动观察追踪（Automatic observation tracking）

UIKit 核心整合 Swift Observation，在 `layoutSubviews()` 等更新方法中自动追踪 `Observable` 类型的状态变化，无需手动调用 `setNeedsLayout`，仅更新依赖该状态的视图，避免全量刷新。

**核心示例 1：视图控制器中状态绑定**

```swift
// 可观察的状态模型
@Observable class UnreadMessagesModel {
    var showStatus: Bool
    var statusText: String
}

class MessageListViewController: UIViewController {
    var unreadMessagesModel: UnreadMessagesModel
    var statusLabel: UILabel
    
    override func viewWillLayoutSubviews() {
        super.viewWillLayoutSubviews()
        // 自动追踪模型状态，变化时仅更新该标签
        statusLabel.alpha = unreadMessagesModel.showStatus ? 1.0 : 0.0
        statusLabel.text = unreadMessagesModel.statusText
    }
}
```

**核心示例 2：集合视图单元格数据绑定**

```swift
@Observable class ListItemModel {
    var icon: UIImage
    var title: String
    var subtitle: String
}

func collectionView(
    _ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath
) -> UICollectionViewCell {
    let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "Cell", for: indexPath)
    let listItemModel = listItemModel(for: indexPath)
    // 单元格配置自动追踪模型状态
    cell.configurationUpdateHandler = { cell, state in
        var content = UIListContentConfiguration.subtitleCell()
        content.image = listItemModel.icon
        content.text = listItemModel.title
        content.secondaryText = listItemModel.subtitle
        cell.contentConfiguration = content
    }
    return cell
}
```

### 3.2 新增 UI 更新方法：updateProperties()

`UIView` / `UIViewController` 新增 **updateProperties()** 方法，在 `layoutSubviews()` 之前执行，专门用于属性配置，实现「属性更新」与「布局计算」解耦，避免因布局调整（如大小变化）重复执行属性配置代码，减少冗余操作。

**核心示例：导航栏角标配置**

```swift
@Observable class BadgeModel {
   var badgeCount: Int?
}

class MyViewController: UIViewController {
   var model: BadgeModel
   let folderButton: UIBarButtonItem

    override func updateProperties() {
        super.updateProperties()
        // 仅在角标数量变化时更新，与布局调整解耦
        if let badgeCount = model.badgeCount {
            folderButton.badge = .count(badgeCount)
        } else {
            folderButton.badge = nil
        }
   }
}
```

**updateProperties() 融入视图更新流程**

UIKit 视图显示前的原有流程为「更新特征 → layoutSubviews() → draw() → 渲染」，新增方法后流程重构，且特征集合在 `updateProperties()` 前已完成更新，可直接读取并标记布局失效。

![uikit5](https://github.com/JasonMR7/JasonMR7.github.io/raw/master/assets/images/2025-06-09-iOS-26-UIKit-新特性全解析/uikit5.webp)
![uikit6](https://github.com/JasonMR7/JasonMR7.github.io/raw/master/assets/images/2025-06-09-iOS-26-UIKit-新特性全解析/uikit6.webp)
![uikit7](https://github.com/JasonMR7/JasonMR7.github.io/raw/master/assets/images/2025-06-09-iOS-26-UIKit-新特性全解析/uikit7.webp)

### 3.3 动画逻辑优化：flushUpdates 选项

为解决传统动画中「手动调用 layoutIfNeeded() 易出错」的问题，iOS 26 新增 **flushUpdates** 动画选项，启用后 UIKit 会在动画开始前自动应用待处理的状态更新，结束时再次同步，无需手动调用布局刷新方法，支持 Observable 状态更新、自动布局约束调整等场景。

**传统动画（需手动调用 layoutIfNeeded()）**

```swift
UIView.animate {
    model.badgeColor = .red
    badgeView.layoutIfNeeded() // 必须手动调用，否则动画不生效
}
```

**新动画（flushUpdates 自动处理）**

```swift
// 1. Observable 状态更新动画
UIView.animate(options: .flushUpdates) {
    model.badgeColor = .red // 无需手动刷新布局
}

// 2. 自动布局约束调整动画
UIView.animate(options: .flushUpdates) {
    topSpacingConstraint.constant = 20 // 修改约束常量
    leadingEdgeConstraint.isActive = false // 切换约束状态
    trailingEdgeConstraint.isActive = true
}
```

---

## 四、通用能力增强（General enhancements）

### 4.1 UIColor 支持 HDR 色彩（HDR Color support）

`UIColor` 新增线性曝光值配置，可同时指定 SDR 基础色和曝光值，系统会根据设备显示能力自动调整亮度，实现「亮部更亮、暗部更暗且保留细节」的 HDR 效果，大幅提升视觉沉浸感。

```swift
// 创建HDR红色：基础色为纯红，线性曝光值2.5
let hdrRed = UIColor(red: 1.0, green: 0.0, blue: 0.0, alpha: 1.0, linearExposure: 2.5)
```

### 4.2 Swift 强类型通知（Adopting Swift notification）

UIKit 弃用传统 `userInfo` 字典式通知，新增 **NotificationCenter.Message** 强类型通知，注册观察者、获取通知信息均为强类型，无需手动类型转换，简化代码且避免类型错误。

```swift
override func viewDidLoad() {
    super.viewDidLoad()
    // 注册键盘弹出强类型通知
    let keyboardObserver = NotificationCenter.default.addObserver(
        of: UIScreen.self
        for: .keyboardWillShow
    ) { message in
        // 直接获取动画时长、键盘最终帧等强类型属性
        UIView.animate(
            withDuration: message.animationDuration, delay: 0, options: .flushUpdates
        ) {
            let keyboardOverlap = view.bounds.maxY - message.endFrame.minY
            bottomConstraint.constant = keyboardOverlap
        }
    }
}
```

### 4.3 UIScreen 与生命周期：强制适配 UIScene

为提升 App 便携性和灵活性，iOS 26 逐步弃用 `UIApplication` 相关旧 API，强制要求基于 **UIScene** 生命周期开发：

- 旧版 `UIApplicationDelegate` 回调、`UIApplicationLaunchOptionKeys` 不再适用；
- 仅保留 `UIWindow.init(windowScene:)` 初始化方法，其余均弃用；
- 后续 SDK 构建的 UIKit App 若未适配 UIScene，将无法启动。

### 4.4 openURL 支持文件 URL

`openURL` 方法新增文件 URL 支持，可直接传递 App 不原生支持的文档：

- 若系统存在该文件类型的默认打开 App，自动启动并传递 URL；
- 若不存在，返回 `false`，开发者可自定义回退逻辑（如使用快速预览控制器）。

### 4.5 SF Symbols 7 新增效果

系统图标库 SF Symbols 7 迎来升级，新增三大核心效果，丰富图标交互与视觉表现：

- **Draw off & Draw on**：图标绘制 / 擦除的动态效果；
- **Variable Draw**：图标可变宽度 / 粗细的动态绘制；
- **Magic replace**：图标替换的过渡动画效果。

<video src="https://github.com/JasonMR7/JasonMR7.github.io/raw/master/assets/images/2025-06-09-iOS-26-UIKit-新特性全解析/uikit5.mp4" controls playsinline></video>

<video src="https://github.com/JasonMR7/JasonMR7.github.io/raw/master/assets/images/2025-06-09-iOS-26-UIKit-新特性全解析/uikit6.mp4" controls playsinline></video>

<video src="https://github.com/JasonMR7/JasonMR7.github.io/raw/master/assets/images/2025-06-09-iOS-26-UIKit-新特性全解析/uikit7.mp4" controls playsinline></video>

---

## 五、基于新设计构建 UIKit 应用（Build a UIKit app with the new design）

iOS 26 针对标签栏、分屏、导航栏、工具栏等核心容器，以及开关、按钮、滑块等基础控件，基于 Liquid Glass 材质进行重构，同时提供丰富的自定义配置能力，以下为核心组件的新特性与使用方法。

### 5.1 标签栏与分屏（Tab views and split views）

#### 5.1.1 标签栏支持滚动最小化

```swift
// 向下滚动时自动最小化标签栏
tabBarController.tabBarMinimizeBehavior = .onScrollDown
```
<video src="https://github.com/JasonMR7/JasonMR7.github.io/raw/master/assets/images/2025-06-09-iOS-26-UIKit-新特性全解析/uikit8.mp4" controls playsinline></video>

#### 5.1.2 标签栏添加底部附属视图

支持自定义底部附属视图（如播放控件），并可通过特征追踪适配不同展示状态：

```swift
// 添加底部附属视图（如正在播放视图）
let nowPlayingView = NowPlayingView()
let accessory = UITabAccessory(contentView: nowPlayingView)
tabBarController.bottomAccessory = accessory

// 方式1：手动注册特征变化追踪
registerForTraitChanges([UITraitTabAccessoryEnvironment.self]) { (view: MiniPlayerView, _) in
    let isInline = view.traitCollection.tabAccessoryEnvironment == .inline
    view.updatePlayerAppearance(inline: isInline)
}

// 方式2：通过updateProperties()自动追踪
override func updateProperties() {
    super.updateProperties()
    let isInline = traitCollection.tabAccessoryEnvironment == .inline
    updatePlayerAppearance(inline: isInline)
}
```

<video src="https://github.com/JasonMR7/JasonMR7.github.io/raw/master/assets/images/2025-06-09-iOS-26-UIKit-新特性全解析/uikit9.mp4" controls playsinline></video>

![uikit8](https://github.com/JasonMR7/JasonMR7.github.io/raw/master/assets/images/2025-06-09-iOS-26-UIKit-新特性全解析/uikit8.webp)

#### 5.1.3 背景扩展视图（UIBackgroundExtensionView）

支持将内容延伸至侧边栏下方，可自定义布局或使用自动布局，适配分屏场景的视觉延伸需求：

```swift
// 基础用法：将海报图延伸至侧边栏下方
let posterImageView = UIImageView(image: ...)
let extensionView = UIBackgroundExtensionView()
extensionView.contentView = posterImageView
view.addSubview(extensionView)

// 自定义布局用法：手动设置 extensionView 的 frame 或约束
extensionView.frame = view.bounds
extensionView.autoresizingMask = [.flexibleWidth, .flexibleHeight]
```

![uikit9](https://github.com/JasonMR7/JasonMR7.github.io/raw/master/assets/images/2025-06-09-iOS-26-UIKit-新特性全解析/uikit9.webp)

---

以上为 iOS 26 UIKit 核心新特性的梳理与示例，建议在真机或模拟器上结合官方 Sample 与文档逐步尝试，以便更好地将 Liquid Glass 设计体系与架构优化应用到实际项目中。
